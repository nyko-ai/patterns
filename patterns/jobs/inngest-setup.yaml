id: inngest-setup
version: "1.0.0"
updated_at: "2026-01-31"
author: "nyko-team"
status: beta

name: "Inngest Background Jobs"
description: "Serverless background jobs and workflows with Inngest including retries, scheduling, and fan-out"

category: jobs
tags:
  - inngest
  - background-jobs
  - workflows
  - serverless
  - queues

difficulty: intermediate
time_estimate: "25-30 min"

stack:
  required:
    - name: "next"
      version: "^15.1.0"
      reason: "App Router"
    - name: "inngest"
      version: "^3.50.0"
      reason: "Background jobs SDK"

requires: []

enables: []

env_vars:
  required:
    - key: INNGEST_EVENT_KEY
      description: "Inngest event key for sending events"
      format: "xxxxxxxx"
      where_to_find: "Inngest Dashboard > Manage > Event Keys"
    - key: INNGEST_SIGNING_KEY
      description: "Inngest signing key for webhook verification"
      format: "signkey-xxxx-xxxx"
      where_to_find: "Inngest Dashboard > Manage > Signing Key"

external_setup:
  - service: "Inngest"
    url: "https://app.inngest.com"
    steps:
      - "Create account at inngest.com"
      - "Create a new app or use default"
      - "Copy Event Key from Manage > Event Keys"
      - "Copy Signing Key from Manage > Signing Key"
      - "For development, run: npx inngest-cli@latest dev"

files:
  - path: "lib/inngest/client.ts"
    action: create
    description: "Inngest client configuration"
    priority: 1

  - path: "lib/inngest/functions.ts"
    action: create
    description: "Inngest function definitions"
    priority: 2

  - path: "app/api/inngest/route.ts"
    action: create
    description: "Inngest API route handler"
    priority: 3

  - path: "lib/inngest/events.ts"
    action: create
    description: "Type-safe event definitions"
    priority: 4

  - path: "lib/inngest/workflows.ts"
    action: create
    description: "Complex workflow examples"
    priority: 5

code:
  lib/inngest/client.ts: |
    import { Inngest } from "inngest";
    import type { Events } from "./events";

    /**
     * Inngest client - use this to send events
     */
    export const inngest = new Inngest({
      id: "my-app", // Your app identifier
      schemas: new Map<keyof Events, { data: Events[keyof Events] }>(),
    });

    /**
     * Send an event to trigger functions
     */
    export async function sendEvent<K extends keyof Events>(
      name: K,
      data: Events[K]
    ): Promise<void> {
      await inngest.send({
        name,
        data,
      });
    }

    /**
     * Send multiple events at once
     */
    export async function sendEvents<K extends keyof Events>(
      events: { name: K; data: Events[K] }[]
    ): Promise<void> {
      await inngest.send(events);
    }

    /**
     * Send event with delay
     */
    export async function sendEventWithDelay<K extends keyof Events>(
      name: K,
      data: Events[K],
      delayMs: number
    ): Promise<void> {
      // Use scheduled events for delays
      const scheduledAt = new Date(Date.now() + delayMs);
      await inngest.send({
        name,
        data,
        ts: scheduledAt.getTime(),
      });
    }

  lib/inngest/events.ts: |
    /**
     * Type-safe event definitions
     *
     * Define all your events here for type safety across your app
     */
    export interface Events {
      // User events
      "user/created": {
        userId: string;
        email: string;
        name: string;
      };
      "user/updated": {
        userId: string;
        changes: Record<string, unknown>;
      };
      "user/deleted": {
        userId: string;
      };

      // Email events
      "email/send.welcome": {
        userId: string;
        email: string;
        name: string;
      };
      "email/send.notification": {
        userId: string;
        email: string;
        subject: string;
        body: string;
      };
      "email/send.digest": {
        userId: string;
        email: string;
        items: { title: string; url: string }[];
      };

      // Processing events
      "process/image": {
        imageId: string;
        imageUrl: string;
        operations: ("resize" | "compress" | "convert")[];
      };
      "process/video": {
        videoId: string;
        videoUrl: string;
        outputFormat: string;
      };

      // Sync events
      "sync/external.api": {
        userId: string;
        service: string;
        lastSyncAt?: string;
      };

      // Scheduled events
      "cron/daily.cleanup": Record<string, never>;
      "cron/hourly.sync": Record<string, never>;

      // Webhook events
      "webhook/stripe.payment": {
        paymentId: string;
        amount: number;
        customerId: string;
      };
    }

    /**
     * Event name type
     */
    export type EventName = keyof Events;

    /**
     * Get event data type
     */
    export type EventData<K extends EventName> = Events[K];

  lib/inngest/functions.ts: |
    import { inngest } from "./client";

    /**
     * Send welcome email when user signs up
     */
    export const sendWelcomeEmail = inngest.createFunction(
      {
        id: "send-welcome-email",
        retries: 3,
      },
      { event: "user/created" },
      async ({ event, step }) => {
        // Step 1: Get user details
        const user = await step.run("get-user", async () => {
          // Replace with your database call
          return {
            id: event.data.userId,
            email: event.data.email,
            name: event.data.name,
          };
        });

        // Step 2: Send welcome email
        await step.run("send-email", async () => {
          // Replace with your email service
          console.log(`Sending welcome email to ${user.email}`);
          // await resend.emails.send({
          //   to: user.email,
          //   subject: `Welcome, ${user.name}!`,
          //   ...
          // });
        });

        // Step 3: Track analytics
        await step.run("track-signup", async () => {
          // Replace with your analytics
          console.log(`Tracking signup for user ${user.id}`);
        });

        return { success: true, userId: user.id };
      }
    );

    /**
     * Process image with retries and timeout
     */
    export const processImage = inngest.createFunction(
      {
        id: "process-image",
        retries: 5,
        concurrency: {
          limit: 10, // Max 10 concurrent image processing
        },
      },
      { event: "process/image" },
      async ({ event, step }) => {
        const { imageId, imageUrl, operations } = event.data;

        // Process each operation as a step
        const results: Record<string, string> = {};

        for (const operation of operations) {
          const result = await step.run(`process-${operation}`, async () => {
            console.log(`Processing ${operation} for image ${imageId}`);

            // Replace with actual image processing
            switch (operation) {
              case "resize":
                return `${imageUrl}?w=800`;
              case "compress":
                return `${imageUrl}?q=80`;
              case "convert":
                return imageUrl.replace(/\.[^.]+$/, ".webp");
              default:
                return imageUrl;
            }
          });

          results[operation] = result;
        }

        // Update database with results
        await step.run("update-database", async () => {
          console.log(`Updating image ${imageId} with results`);
          // await db.image.update({ where: { id: imageId }, data: results });
        });

        return { imageId, results };
      }
    );

    /**
     * Send notification email
     */
    export const sendNotificationEmail = inngest.createFunction(
      {
        id: "send-notification-email",
        retries: 3,
      },
      { event: "email/send.notification" },
      async ({ event, step }) => {
        await step.run("send-email", async () => {
          const { email, subject, body } = event.data;
          console.log(`Sending notification to ${email}: ${subject}`);
          // await resend.emails.send({ to: email, subject, html: body });
        });

        return { sent: true };
      }
    );

    /**
     * Daily cleanup cron job
     */
    export const dailyCleanup = inngest.createFunction(
      {
        id: "daily-cleanup",
      },
      { cron: "0 2 * * *" }, // Run at 2 AM daily
      async ({ step }) => {
        // Step 1: Clean up expired sessions
        const sessionsDeleted = await step.run("cleanup-sessions", async () => {
          console.log("Cleaning up expired sessions");
          // const result = await db.session.deleteMany({
          //   where: { expiresAt: { lt: new Date() } },
          // });
          // return result.count;
          return 0;
        });

        // Step 2: Clean up old logs
        const logsDeleted = await step.run("cleanup-logs", async () => {
          console.log("Cleaning up old logs");
          // const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
          // const result = await db.log.deleteMany({
          //   where: { createdAt: { lt: thirtyDaysAgo } },
          // });
          // return result.count;
          return 0;
        });

        // Step 3: Clean up orphaned files
        const filesDeleted = await step.run("cleanup-files", async () => {
          console.log("Cleaning up orphaned files");
          return 0;
        });

        return {
          sessionsDeleted,
          logsDeleted,
          filesDeleted,
          completedAt: new Date().toISOString(),
        };
      }
    );

    /**
     * Sync with external API
     */
    export const syncExternalApi = inngest.createFunction(
      {
        id: "sync-external-api",
        retries: 3,
        throttle: {
          limit: 10,
          period: "1m", // Max 10 syncs per minute
        },
      },
      { event: "sync/external.api" },
      async ({ event, step }) => {
        const { userId, service, lastSyncAt } = event.data;

        // Fetch data from external API
        const data = await step.run("fetch-external-data", async () => {
          console.log(`Fetching data from ${service} for user ${userId}`);
          // const response = await fetch(`https://api.${service}.com/data`);
          // return response.json();
          return { items: [] };
        });

        // Process and store data
        await step.run("store-data", async () => {
          console.log(`Storing ${data.items.length} items for user ${userId}`);
          // await db.syncedData.createMany({ data: data.items });
        });

        // Update last sync timestamp
        await step.run("update-sync-status", async () => {
          // await db.user.update({
          //   where: { id: userId },
          //   data: { lastSyncAt: new Date() },
          // });
        });

        return {
          userId,
          service,
          itemsSynced: data.items.length,
        };
      }
    );

    /**
     * Export all functions for the route handler
     */
    export const functions = [
      sendWelcomeEmail,
      processImage,
      sendNotificationEmail,
      dailyCleanup,
      syncExternalApi,
    ];

  app/api/inngest/route.ts: |
    import { serve } from "inngest/next";
    import { inngest } from "@/lib/inngest/client";
    import { functions } from "@/lib/inngest/functions";

    /**
     * Inngest API route handler
     *
     * This endpoint:
     * 1. Receives events from Inngest Cloud
     * 2. Executes the appropriate function
     * 3. Reports results back to Inngest
     */
    export const { GET, POST, PUT } = serve({
      client: inngest,
      functions,
    });

  lib/inngest/workflows.ts: |
    import { inngest } from "./client";

    /**
     * Complex workflow: User onboarding
     *
     * Demonstrates:
     * - Multiple steps
     * - Delays between steps
     * - Conditional logic
     * - Fan-out pattern
     */
    export const userOnboarding = inngest.createFunction(
      {
        id: "user-onboarding-workflow",
        retries: 3,
      },
      { event: "user/created" },
      async ({ event, step }) => {
        const { userId, email, name } = event.data;

        // Step 1: Send welcome email immediately
        await step.run("send-welcome-email", async () => {
          console.log(`Sending welcome email to ${email}`);
          // await sendEmail({ to: email, template: "welcome", data: { name } });
        });

        // Step 2: Wait 1 day before follow-up
        await step.sleep("wait-for-first-day", "1d");

        // Step 3: Check if user has completed profile
        const profileComplete = await step.run("check-profile", async () => {
          // const user = await db.user.findUnique({ where: { id: userId } });
          // return user?.profileComplete ?? false;
          return false;
        });

        // Step 4: Send reminder if profile incomplete
        if (!profileComplete) {
          await step.run("send-profile-reminder", async () => {
            console.log(`Sending profile reminder to ${email}`);
            // await sendEmail({ to: email, template: "complete-profile" });
          });
        }

        // Step 5: Wait 3 more days
        await step.sleep("wait-for-activity", "3d");

        // Step 6: Check user activity
        const hasActivity = await step.run("check-activity", async () => {
          // const actions = await db.userAction.count({ where: { userId } });
          // return actions > 0;
          return false;
        });

        // Step 7: Send engagement email if inactive
        if (!hasActivity) {
          await step.run("send-engagement-email", async () => {
            console.log(`Sending engagement email to ${email}`);
            // await sendEmail({ to: email, template: "get-started-tips" });
          });
        }

        return {
          userId,
          profileComplete,
          hasActivity,
          completedAt: new Date().toISOString(),
        };
      }
    );

    /**
     * Fan-out workflow: Process batch
     *
     * Demonstrates processing multiple items in parallel
     */
    export const processBatch = inngest.createFunction(
      {
        id: "process-batch",
        retries: 2,
      },
      { event: "process/batch" as any },
      async ({ event, step }) => {
        const items = (event.data as any).items as string[];

        // Process all items in parallel using step.run
        const results = await Promise.all(
          items.map((item, index) =>
            step.run(`process-item-${index}`, async () => {
              console.log(`Processing item: ${item}`);
              // Simulate processing
              return { item, processed: true };
            })
          )
        );

        // Aggregate results
        const summary = await step.run("aggregate-results", async () => {
          return {
            total: results.length,
            successful: results.filter((r) => r.processed).length,
          };
        });

        return summary;
      }
    );

    /**
     * Scheduled report generation
     */
    export const weeklyReport = inngest.createFunction(
      {
        id: "weekly-report",
      },
      { cron: "0 9 * * 1" }, // Every Monday at 9 AM
      async ({ step }) => {
        // Gather data
        const stats = await step.run("gather-stats", async () => {
          // const users = await db.user.count({ where: { createdAt: { gte: lastWeek } } });
          // const revenue = await getWeeklyRevenue();
          return {
            newUsers: 0,
            activeUsers: 0,
            revenue: 0,
          };
        });

        // Generate report
        const report = await step.run("generate-report", async () => {
          return {
            ...stats,
            generatedAt: new Date().toISOString(),
          };
        });

        // Send to stakeholders
        await step.run("send-report", async () => {
          console.log("Sending weekly report");
          // await sendEmail({
          //   to: ["team@company.com"],
          //   subject: "Weekly Report",
          //   data: report,
          // });
        });

        return report;
      }
    );

edge_cases:
  - id: function-timeout
    symptom: "Function fails with timeout error"
    cause: "Step takes too long to complete"
    solution: |
      1. Break long operations into smaller steps
      2. Use step.sleep for delays instead of setTimeout
      3. Configure function timeout:

      inngest.createFunction(
        {
          id: "long-running-task",
          timeouts: {
            finish: "30m", // Max 30 minutes total
          },
        },
        ...
      );

  - id: duplicate-events
    symptom: "Function runs multiple times for same event"
    cause: "Event sent multiple times or retry without idempotency"
    solution: |
      1. Make steps idempotent (can run multiple times safely)
      2. Use idempotency keys:

      await inngest.send({
        name: "user/created",
        data: { userId: "123" },
        id: `user-created-${userId}`, // Idempotency key
      });

      3. Check for existing state in steps

  - id: dev-server-not-connected
    symptom: "Events not triggering functions locally"
    cause: "Inngest dev server not running or not connected"
    solution: |
      1. Start Inngest dev server:
         npx inngest-cli@latest dev

      2. Ensure your app is running on the correct port
      3. Check the Inngest dev dashboard at http://localhost:8288
      4. Verify /api/inngest route is accessible

  - id: step-failure-handling
    symptom: "Need to handle step failures gracefully"
    cause: "Step throws an error"
    solution: |
      Use try-catch within steps or use step.invoke for retries:

      try {
        await step.run("risky-operation", async () => {
          // This might fail
        });
      } catch (error) {
        await step.run("handle-failure", async () => {
          // Log error, send notification, etc.
        });
      }

validation:
  manual_test:
    - "Start Inngest dev server: npx inngest-cli@latest dev"
    - "Start your Next.js app"
    - "Send a test event from Inngest dashboard"
    - "Verify function executes correctly"
    - "Test retry behavior by throwing an error"
    - "Check step execution in Inngest dashboard"
