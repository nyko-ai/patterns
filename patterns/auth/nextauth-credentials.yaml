id: nextauth-credentials
version: "1.0.0"
updated_at: "2026-01-31"
author: "nyko-team"
status: beta

name: "NextAuth.js Credentials Authentication"
description: "Email/password authentication with NextAuth.js, Prisma adapter, and JWT sessions"

category: auth
tags:
  - nextauth
  - credentials
  - email
  - password
  - prisma
  - jwt
  - nextjs

difficulty: intermediate
time_estimate: "25-35 min"

stack:
  required:
    - name: "next"
      version: "^15.1.0"
      reason: "App Router with server components"
    - name: "next-auth"
      version: "^5.0.0-beta.25"
      reason: "Authentication library (Auth.js v5)"
    - name: "@prisma/client"
      version: "^6.0.0"
      reason: "Database ORM"
    - name: "prisma"
      version: "^6.0.0"
      reason: "Prisma CLI for migrations"
    - name: "@auth/prisma-adapter"
      version: "^2.7.4"
      reason: "NextAuth Prisma adapter"
    - name: "bcryptjs"
      version: "^2.4.3"
      reason: "Password hashing"
    - name: "@types/bcryptjs"
      version: "^2.4.6"
      reason: "TypeScript types for bcryptjs"
    - name: "zod"
      version: "^3.24.0"
      reason: "Schema validation"

requires: []

enables:
  - resend-verify-email

env_vars:
  required:
    - key: DATABASE_URL
      description: "PostgreSQL connection string"
      format: "postgresql://user:password@host:5432/database"
      where_to_find: "Your database provider dashboard"
    - key: AUTH_SECRET
      description: "NextAuth secret for JWT signing"
      format: "Random 32+ character string"
      where_to_find: "Generate with: openssl rand -base64 32"
  optional:
    - key: AUTH_URL
      description: "NextAuth base URL (auto-detected in production)"
      default: "http://localhost:3000"

external_setup:
  - service: "Database Provider"
    url: "https://neon.tech or https://supabase.com"
    steps:
      - "Create a new PostgreSQL database"
      - "Copy the connection string"
      - "Add DATABASE_URL to your .env file"
      - "Run: npx prisma db push"

files:
  - path: "prisma/schema.prisma"
    action: create
    description: "Prisma schema with NextAuth models"
    priority: 1

  - path: "lib/prisma.ts"
    action: create
    description: "Prisma client singleton"
    priority: 2

  - path: "lib/auth.ts"
    action: create
    description: "NextAuth configuration"
    priority: 3

  - path: "app/api/auth/[...nextauth]/route.ts"
    action: create
    description: "NextAuth API route handler"
    priority: 4

  - path: "app/api/auth/register/route.ts"
    action: create
    description: "User registration endpoint"
    priority: 5

  - path: "lib/validations/auth.ts"
    action: create
    description: "Zod schemas for auth validation"
    priority: 6

  - path: "app/login/page.tsx"
    action: create
    description: "Login page"
    priority: 7

  - path: "app/register/page.tsx"
    action: create
    description: "Registration page"
    priority: 8

  - path: "components/auth/login-form.tsx"
    action: create
    description: "Login form component"
    priority: 9

  - path: "components/auth/register-form.tsx"
    action: create
    description: "Registration form component"
    priority: 10

  - path: "middleware.ts"
    action: create
    description: "Auth middleware for protected routes"
    priority: 11

code:
  prisma/schema.prisma: |
    generator client {
      provider = "prisma-client-js"
    }

    datasource db {
      provider = "postgresql"
      url      = env("DATABASE_URL")
    }

    model User {
      id            String    @id @default(cuid())
      name          String?
      email         String    @unique
      emailVerified DateTime?
      image         String?
      password      String?
      accounts      Account[]
      sessions      Session[]
      createdAt     DateTime  @default(now())
      updatedAt     DateTime  @updatedAt
    }

    model Account {
      userId            String
      type              String
      provider          String
      providerAccountId String
      refresh_token     String?
      access_token      String?
      expires_at        Int?
      token_type        String?
      scope             String?
      id_token          String?
      session_state     String?
      createdAt         DateTime @default(now())
      updatedAt         DateTime @updatedAt
      user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

      @@id([provider, providerAccountId])
    }

    model Session {
      sessionToken String   @unique
      userId       String
      expires      DateTime
      user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
      createdAt    DateTime @default(now())
      updatedAt    DateTime @updatedAt
    }

    model VerificationToken {
      identifier String
      token      String
      expires    DateTime

      @@id([identifier, token])
    }

  lib/prisma.ts: |
    import { PrismaClient } from "@prisma/client";

    const globalForPrisma = globalThis as unknown as {
      prisma: PrismaClient | undefined;
    };

    export const prisma = globalForPrisma.prisma ?? new PrismaClient();

    if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

  lib/auth.ts: |
    import NextAuth from "next-auth";
    import Credentials from "next-auth/providers/credentials";
    import { PrismaAdapter } from "@auth/prisma-adapter";
    import { prisma } from "@/lib/prisma";
    import bcrypt from "bcryptjs";
    import { loginSchema } from "@/lib/validations/auth";

    export const { handlers, auth, signIn, signOut } = NextAuth({
      adapter: PrismaAdapter(prisma),
      session: { strategy: "jwt" },
      pages: {
        signIn: "/login",
      },
      providers: [
        Credentials({
          credentials: {
            email: { label: "Email", type: "email" },
            password: { label: "Password", type: "password" },
          },
          async authorize(credentials) {
            const validated = loginSchema.safeParse(credentials);
            if (!validated.success) return null;

            const { email, password } = validated.data;

            const user = await prisma.user.findUnique({
              where: { email },
            });

            if (!user || !user.password) return null;

            const passwordMatch = await bcrypt.compare(password, user.password);
            if (!passwordMatch) return null;

            return {
              id: user.id,
              email: user.email,
              name: user.name,
              image: user.image,
            };
          },
        }),
      ],
      callbacks: {
        async session({ session, token }) {
          if (token.sub && session.user) {
            session.user.id = token.sub;
          }
          return session;
        },
        async jwt({ token, user }) {
          if (user) {
            token.sub = user.id;
          }
          return token;
        },
      },
    });

  app/api/auth/[...nextauth]/route.ts: |
    import { handlers } from "@/lib/auth";

    export const { GET, POST } = handlers;

  app/api/auth/register/route.ts: |
    import { NextResponse } from "next/server";
    import { prisma } from "@/lib/prisma";
    import bcrypt from "bcryptjs";
    import { registerSchema } from "@/lib/validations/auth";

    export async function POST(request: Request) {
      try {
        const body = await request.json();
        const validated = registerSchema.safeParse(body);

        if (!validated.success) {
          return NextResponse.json(
            { error: "Invalid input", details: validated.error.flatten() },
            { status: 400 }
          );
        }

        const { email, password, name } = validated.data;

        const existingUser = await prisma.user.findUnique({
          where: { email },
        });

        if (existingUser) {
          return NextResponse.json(
            { error: "Email already registered" },
            { status: 409 }
          );
        }

        const hashedPassword = await bcrypt.hash(password, 12);

        const user = await prisma.user.create({
          data: {
            email,
            password: hashedPassword,
            name,
          },
        });

        return NextResponse.json(
          { message: "User created successfully", userId: user.id },
          { status: 201 }
        );
      } catch (error) {
        console.error("Registration error:", error);
        return NextResponse.json(
          { error: "Internal server error" },
          { status: 500 }
        );
      }
    }

  lib/validations/auth.ts: |
    import { z } from "zod";

    export const loginSchema = z.object({
      email: z.string().email("Invalid email address"),
      password: z.string().min(1, "Password is required"),
    });

    export const registerSchema = z.object({
      email: z.string().email("Invalid email address"),
      password: z
        .string()
        .min(8, "Password must be at least 8 characters")
        .regex(
          /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
          "Password must contain at least one uppercase letter, one lowercase letter, and one number"
        ),
      name: z.string().min(2, "Name must be at least 2 characters").optional(),
    });

    export type LoginInput = z.infer<typeof loginSchema>;
    export type RegisterInput = z.infer<typeof registerSchema>;

  app/login/page.tsx: |
    import { LoginForm } from "@/components/auth/login-form";
    import { auth } from "@/lib/auth";
    import { redirect } from "next/navigation";
    import Link from "next/link";

    export default async function LoginPage() {
      const session = await auth();

      if (session?.user) {
        redirect("/");
      }

      return (
        <div className="flex min-h-screen items-center justify-center">
          <div className="w-full max-w-sm space-y-6 p-8">
            <div className="text-center">
              <h1 className="text-2xl font-bold">Welcome back</h1>
              <p className="text-gray-500 mt-2">
                Sign in to your account to continue
              </p>
            </div>

            <LoginForm />

            <p className="text-center text-sm text-gray-500">
              Don&apos;t have an account?{" "}
              <Link href="/register" className="text-blue-600 hover:underline">
                Sign up
              </Link>
            </p>
          </div>
        </div>
      );
    }

  app/register/page.tsx: |
    import { RegisterForm } from "@/components/auth/register-form";
    import { auth } from "@/lib/auth";
    import { redirect } from "next/navigation";
    import Link from "next/link";

    export default async function RegisterPage() {
      const session = await auth();

      if (session?.user) {
        redirect("/");
      }

      return (
        <div className="flex min-h-screen items-center justify-center">
          <div className="w-full max-w-sm space-y-6 p-8">
            <div className="text-center">
              <h1 className="text-2xl font-bold">Create an account</h1>
              <p className="text-gray-500 mt-2">
                Enter your details to get started
              </p>
            </div>

            <RegisterForm />

            <p className="text-center text-sm text-gray-500">
              Already have an account?{" "}
              <Link href="/login" className="text-blue-600 hover:underline">
                Sign in
              </Link>
            </p>
          </div>
        </div>
      );
    }

  components/auth/login-form.tsx: |
    "use client";

    import { useState } from "react";
    import { signIn } from "next-auth/react";
    import { useRouter } from "next/navigation";

    export function LoginForm() {
      const [email, setEmail] = useState("");
      const [password, setPassword] = useState("");
      const [error, setError] = useState<string | null>(null);
      const [isLoading, setIsLoading] = useState(false);
      const router = useRouter();

      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setIsLoading(true);
        setError(null);

        try {
          const result = await signIn("credentials", {
            email,
            password,
            redirect: false,
          });

          if (result?.error) {
            setError("Invalid email or password");
          } else {
            router.push("/");
            router.refresh();
          }
        } catch {
          setError("Something went wrong. Please try again.");
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label
              htmlFor="email"
              className="block text-sm font-medium text-gray-700"
            >
              Email
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              placeholder="you@example.com"
              className="mt-1 block w-full rounded-lg border border-gray-300 px-4 py-3 shadow-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
            />
          </div>

          <div>
            <label
              htmlFor="password"
              className="block text-sm font-medium text-gray-700"
            >
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              placeholder="Enter your password"
              className="mt-1 block w-full rounded-lg border border-gray-300 px-4 py-3 shadow-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
            />
          </div>

          {error && (
            <div className="rounded-lg bg-red-50 p-3 text-sm text-red-600">
              {error}
            </div>
          )}

          <button
            type="submit"
            disabled={isLoading}
            className="w-full rounded-lg bg-blue-600 px-4 py-3 text-sm font-medium text-white shadow-sm transition-colors hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
          >
            {isLoading ? "Signing in..." : "Sign in"}
          </button>
        </form>
      );
    }

  components/auth/register-form.tsx: |
    "use client";

    import { useState } from "react";
    import { useRouter } from "next/navigation";

    export function RegisterForm() {
      const [name, setName] = useState("");
      const [email, setEmail] = useState("");
      const [password, setPassword] = useState("");
      const [error, setError] = useState<string | null>(null);
      const [isLoading, setIsLoading] = useState(false);
      const router = useRouter();

      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setIsLoading(true);
        setError(null);

        try {
          const response = await fetch("/api/auth/register", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name, email, password }),
          });

          const data = await response.json();

          if (!response.ok) {
            setError(data.error || "Registration failed");
            return;
          }

          router.push("/login?registered=true");
        } catch {
          setError("Something went wrong. Please try again.");
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label
              htmlFor="name"
              className="block text-sm font-medium text-gray-700"
            >
              Name (optional)
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="Your name"
              className="mt-1 block w-full rounded-lg border border-gray-300 px-4 py-3 shadow-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
            />
          </div>

          <div>
            <label
              htmlFor="email"
              className="block text-sm font-medium text-gray-700"
            >
              Email
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              placeholder="you@example.com"
              className="mt-1 block w-full rounded-lg border border-gray-300 px-4 py-3 shadow-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
            />
          </div>

          <div>
            <label
              htmlFor="password"
              className="block text-sm font-medium text-gray-700"
            >
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              placeholder="At least 8 characters"
              className="mt-1 block w-full rounded-lg border border-gray-300 px-4 py-3 shadow-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
            />
            <p className="mt-1 text-xs text-gray-500">
              Must contain uppercase, lowercase, and a number
            </p>
          </div>

          {error && (
            <div className="rounded-lg bg-red-50 p-3 text-sm text-red-600">
              {error}
            </div>
          )}

          <button
            type="submit"
            disabled={isLoading}
            className="w-full rounded-lg bg-blue-600 px-4 py-3 text-sm font-medium text-white shadow-sm transition-colors hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
          >
            {isLoading ? "Creating account..." : "Create account"}
          </button>
        </form>
      );
    }

  middleware.ts: |
    import { auth } from "@/lib/auth";
    import { NextResponse } from "next/server";

    export default auth((req) => {
      const isLoggedIn = !!req.auth;
      const isAuthPage = req.nextUrl.pathname.startsWith("/login") ||
                         req.nextUrl.pathname.startsWith("/register");
      const isProtectedRoute = req.nextUrl.pathname.startsWith("/dashboard");

      // Redirect logged-in users away from auth pages
      if (isLoggedIn && isAuthPage) {
        return NextResponse.redirect(new URL("/", req.url));
      }

      // Redirect unauthenticated users to login
      if (!isLoggedIn && isProtectedRoute) {
        return NextResponse.redirect(new URL("/login", req.url));
      }

      return NextResponse.next();
    });

    export const config = {
      matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
    };

edge_cases:
  - id: prisma-not-generated
    symptom: "Cannot find module '@prisma/client'"
    cause: "Prisma client not generated after schema changes"
    solution: |
      Run the following commands:
      1. npx prisma generate
      2. npx prisma db push
      3. Restart your development server

  - id: bcrypt-invalid-hash
    symptom: "Error: Illegal arguments: string, undefined"
    cause: "User exists but has no password (registered via OAuth)"
    solution: |
      The authorize function already handles this by checking if user.password exists.
      If you're seeing this error, ensure the password check is in place:
      if (!user || !user.password) return null;

  - id: session-not-updating
    symptom: "User data not reflecting changes after update"
    cause: "JWT session caches user data"
    solution: |
      Call router.refresh() after any user update to refresh the session.
      For immediate updates, you may need to re-authenticate the user.

  - id: auth-secret-missing
    symptom: "[auth][error] MissingSecret: Please define a secret"
    cause: "AUTH_SECRET environment variable not set"
    solution: |
      1. Generate a secret: openssl rand -base64 32
      2. Add to .env: AUTH_SECRET=your-generated-secret
      3. Restart the development server

validation:
  manual_test:
    - "Run: npx prisma db push"
    - "Start development server: npm run dev"
    - "Navigate to /register"
    - "Create a new account"
    - "Verify redirect to /login"
    - "Log in with created credentials"
    - "Verify redirect to home page"
    - "Refresh page - should remain logged in"
    - "Check database for new user record"
