id: password-reset-flow
version: "1.0.0"
updated_at: "2026-01-31"
author: "nyko-team"
status: beta

name: "Password Reset Flow"
description: "Complete password reset flow with secure token handling"

category: auth
tags:
  - password-reset
  - email
  - security
  - authentication
  - recovery

difficulty: intermediate
time_estimate: "25-35 min"

stack:
  required:
    - name: "next"
      version: "^15.1.0"
      reason: "Next.js App Router"
    - name: "@prisma/client"
      version: "^7.3.0"
      reason: "Token storage"
    - name: "bcrypt"
      version: "^5.1.1"
      reason: "Password hashing"

requires: []

enables: []

env_vars:
  required:
    - key: NEXT_PUBLIC_APP_URL
      description: "Application base URL"
      format: "https://example.com"
      where_to_find: "Your deployment URL"
  optional:
    - key: PASSWORD_RESET_EXPIRY_HOURS
      description: "Hours until reset token expires"
      default: "1"

external_setup: []

files:
  - path: "prisma/schema.prisma"
    action: modify
    description: "Add PasswordResetToken model"
    priority: 1

  - path: "lib/auth/password-reset.ts"
    action: create
    description: "Password reset utilities"
    priority: 2

  - path: "app/api/auth/forgot-password/route.ts"
    action: create
    description: "Request password reset"
    priority: 3

  - path: "app/api/auth/reset-password/route.ts"
    action: create
    description: "Reset password with token"
    priority: 4

  - path: "app/(auth)/forgot-password/page.tsx"
    action: create
    description: "Forgot password form"
    priority: 5

  - path: "app/(auth)/reset-password/page.tsx"
    action: create
    description: "Reset password form"
    priority: 6

code:
  prisma/schema.prisma: |
    // Add to existing schema.prisma

    model PasswordResetToken {
      id        String   @id @default(cuid())
      token     String   @unique
      userId    String
      expiresAt DateTime
      usedAt    DateTime?
      createdAt DateTime @default(now())

      user User @relation(fields: [userId], references: [id], onDelete: Cascade)

      @@index([token])
      @@index([userId])
    }

  lib/auth/password-reset.ts: |
    import { prisma } from "@/lib/prisma";
    import crypto from "crypto";
    import bcrypt from "bcrypt";

    const EXPIRY_HOURS = parseInt(process.env.PASSWORD_RESET_EXPIRY_HOURS || "1");
    const APP_URL = process.env.NEXT_PUBLIC_APP_URL!;

    function generateToken(): string {
      return crypto.randomBytes(32).toString("hex");
    }

    function hashToken(token: string): string {
      return crypto.createHash("sha256").update(token).digest("hex");
    }

    export async function createPasswordResetToken(email: string): Promise<{
      success: boolean;
      resetUrl?: string;
      error?: string;
    }> {
      const user = await prisma.user.findUnique({
        where: { email: email.toLowerCase() },
      });

      // Always return success to prevent email enumeration
      if (!user) {
        return { success: true };
      }

      // Invalidate existing tokens
      await prisma.passwordResetToken.updateMany({
        where: {
          userId: user.id,
          usedAt: null,
          expiresAt: { gt: new Date() },
        },
        data: { expiresAt: new Date() },
      });

      // Rate limiting: max 3 requests per hour
      const recentTokens = await prisma.passwordResetToken.count({
        where: {
          userId: user.id,
          createdAt: { gt: new Date(Date.now() - 60 * 60 * 1000) },
        },
      });

      if (recentTokens >= 3) {
        return { success: true }; // Silent rate limit
      }

      const token = generateToken();
      const hashedToken = hashToken(token);

      await prisma.passwordResetToken.create({
        data: {
          token: hashedToken,
          userId: user.id,
          expiresAt: new Date(Date.now() + EXPIRY_HOURS * 60 * 60 * 1000),
        },
      });

      const resetUrl = `${APP_URL}/reset-password?token=${token}`;

      return { success: true, resetUrl };
    }

    export async function validateResetToken(token: string): Promise<{
      valid: boolean;
      userId?: string;
      error?: string;
    }> {
      const hashedToken = hashToken(token);

      const resetToken = await prisma.passwordResetToken.findUnique({
        where: { token: hashedToken },
        include: { user: true },
      });

      if (!resetToken) {
        return { valid: false, error: "Invalid reset link" };
      }

      if (resetToken.usedAt) {
        return { valid: false, error: "Reset link already used" };
      }

      if (resetToken.expiresAt < new Date()) {
        return { valid: false, error: "Reset link expired" };
      }

      return { valid: true, userId: resetToken.userId };
    }

    export async function resetPassword(
      token: string,
      newPassword: string
    ): Promise<{ success: boolean; error?: string }> {
      const validation = await validateResetToken(token);

      if (!validation.valid) {
        return { success: false, error: validation.error };
      }

      // Validate password strength
      if (newPassword.length < 8) {
        return { success: false, error: "Password must be at least 8 characters" };
      }

      const hashedToken = hashToken(token);
      const hashedPassword = await bcrypt.hash(newPassword, 12);

      await prisma.$transaction([
        prisma.user.update({
          where: { id: validation.userId },
          data: { password: hashedPassword },
        }),
        prisma.passwordResetToken.update({
          where: { token: hashedToken },
          data: { usedAt: new Date() },
        }),
        // Invalidate all sessions (optional)
        // prisma.session.deleteMany({ where: { userId: validation.userId } }),
      ]);

      return { success: true };
    }

    export async function cleanupExpiredTokens(): Promise<number> {
      const result = await prisma.passwordResetToken.deleteMany({
        where: {
          OR: [
            { expiresAt: { lt: new Date() } },
            { usedAt: { not: null } },
          ],
        },
      });

      return result.count;
    }

  app/api/auth/forgot-password/route.ts: |
    import { NextRequest, NextResponse } from "next/server";
    import { createPasswordResetToken } from "@/lib/auth/password-reset";
    // import { sendPasswordResetEmail } from "@/lib/email";

    export async function POST(request: NextRequest) {
      try {
        const { email } = await request.json();

        if (!email || typeof email !== "string") {
          return NextResponse.json(
            { error: "Email is required" },
            { status: 400 }
          );
        }

        const result = await createPasswordResetToken(email);

        if (result.resetUrl) {
          // Send email with reset link
          // await sendPasswordResetEmail(email, result.resetUrl);
          console.log("Password reset URL:", result.resetUrl);
        }

        // Always return success to prevent email enumeration
        return NextResponse.json({
          message: "If an account exists with this email, you will receive a password reset link",
        });
      } catch (error) {
        console.error("Forgot password error:", error);
        return NextResponse.json(
          { error: "Something went wrong" },
          { status: 500 }
        );
      }
    }

  app/api/auth/reset-password/route.ts: |
    import { NextRequest, NextResponse } from "next/server";
    import { resetPassword, validateResetToken } from "@/lib/auth/password-reset";

    export async function GET(request: NextRequest) {
      const token = request.nextUrl.searchParams.get("token");

      if (!token) {
        return NextResponse.json({ error: "Token required" }, { status: 400 });
      }

      const result = await validateResetToken(token);

      return NextResponse.json({
        valid: result.valid,
        error: result.error,
      });
    }

    export async function POST(request: NextRequest) {
      try {
        const { token, password } = await request.json();

        if (!token || !password) {
          return NextResponse.json(
            { error: "Token and password are required" },
            { status: 400 }
          );
        }

        const result = await resetPassword(token, password);

        if (!result.success) {
          return NextResponse.json(
            { error: result.error },
            { status: 400 }
          );
        }

        return NextResponse.json({
          message: "Password reset successfully",
        });
      } catch (error) {
        console.error("Reset password error:", error);
        return NextResponse.json(
          { error: "Something went wrong" },
          { status: 500 }
        );
      }
    }

  app/(auth)/forgot-password/page.tsx: |
    "use client";

    import { useState } from "react";

    export default function ForgotPasswordPage() {
      const [email, setEmail] = useState("");
      const [submitted, setSubmitted] = useState(false);
      const [loading, setLoading] = useState(false);

      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true);

        try {
          await fetch("/api/auth/forgot-password", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ email }),
          });

          setSubmitted(true);
        } catch (error) {
          console.error(error);
        } finally {
          setLoading(false);
        }
      };

      if (submitted) {
        return (
          <div className="max-w-md mx-auto mt-10 p-6">
            <h1 className="text-2xl font-bold mb-4">Check your email</h1>
            <p className="text-gray-600">
              If an account exists with {email}, you will receive a password reset link.
            </p>
          </div>
        );
      }

      return (
        <div className="max-w-md mx-auto mt-10 p-6">
          <h1 className="text-2xl font-bold mb-4">Forgot Password</h1>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <label htmlFor="email" className="block text-sm font-medium">
                Email
              </label>
              <input
                type="email"
                id="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                className="mt-1 block w-full rounded border p-2"
              />
            </div>
            <button
              type="submit"
              disabled={loading}
              className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50"
            >
              {loading ? "Sending..." : "Send Reset Link"}
            </button>
          </form>
        </div>
      );
    }

  app/(auth)/reset-password/page.tsx: |
    "use client";

    import { useState, useEffect } from "react";
    import { useSearchParams, useRouter } from "next/navigation";

    export default function ResetPasswordPage() {
      const searchParams = useSearchParams();
      const router = useRouter();
      const token = searchParams.get("token");

      const [password, setPassword] = useState("");
      const [confirmPassword, setConfirmPassword] = useState("");
      const [loading, setLoading] = useState(false);
      const [validating, setValidating] = useState(true);
      const [error, setError] = useState("");
      const [success, setSuccess] = useState(false);

      useEffect(() => {
        if (!token) {
          setError("Invalid reset link");
          setValidating(false);
          return;
        }

        fetch(`/api/auth/reset-password?token=${token}`)
          .then((res) => res.json())
          .then((data) => {
            if (!data.valid) {
              setError(data.error || "Invalid reset link");
            }
          })
          .finally(() => setValidating(false));
      }, [token]);

      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError("");

        if (password !== confirmPassword) {
          setError("Passwords do not match");
          return;
        }

        if (password.length < 8) {
          setError("Password must be at least 8 characters");
          return;
        }

        setLoading(true);

        try {
          const res = await fetch("/api/auth/reset-password", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token, password }),
          });

          const data = await res.json();

          if (!res.ok) {
            setError(data.error);
            return;
          }

          setSuccess(true);
          setTimeout(() => router.push("/login"), 3000);
        } catch {
          setError("Something went wrong");
        } finally {
          setLoading(false);
        }
      };

      if (validating) {
        return <div className="max-w-md mx-auto mt-10 p-6">Validating...</div>;
      }

      if (error && !password) {
        return (
          <div className="max-w-md mx-auto mt-10 p-6">
            <h1 className="text-2xl font-bold mb-4 text-red-600">Error</h1>
            <p>{error}</p>
            <a href="/forgot-password" className="text-blue-600 hover:underline">
              Request new reset link
            </a>
          </div>
        );
      }

      if (success) {
        return (
          <div className="max-w-md mx-auto mt-10 p-6">
            <h1 className="text-2xl font-bold mb-4 text-green-600">Success!</h1>
            <p>Your password has been reset. Redirecting to login...</p>
          </div>
        );
      }

      return (
        <div className="max-w-md mx-auto mt-10 p-6">
          <h1 className="text-2xl font-bold mb-4">Reset Password</h1>
          <form onSubmit={handleSubmit} className="space-y-4">
            {error && <p className="text-red-600">{error}</p>}
            <div>
              <label htmlFor="password" className="block text-sm font-medium">
                New Password
              </label>
              <input
                type="password"
                id="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                minLength={8}
                className="mt-1 block w-full rounded border p-2"
              />
            </div>
            <div>
              <label htmlFor="confirm" className="block text-sm font-medium">
                Confirm Password
              </label>
              <input
                type="password"
                id="confirm"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                required
                className="mt-1 block w-full rounded border p-2"
              />
            </div>
            <button
              type="submit"
              disabled={loading}
              className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50"
            >
              {loading ? "Resetting..." : "Reset Password"}
            </button>
          </form>
        </div>
      );
    }

edge_cases:
  - id: email-enumeration
    symptom: "Attacker can determine valid emails"
    cause: "Different responses for existing vs non-existing emails"
    solution: "Always return same response regardless of email existence"

  - id: token-reuse
    symptom: "Reset link used multiple times"
    cause: "Token not invalidated after use"
    solution: "Mark token as used immediately, check usedAt before reset"

  - id: brute-force
    symptom: "Attacker guesses valid tokens"
    cause: "Token too short or predictable"
    solution: "Use 32+ byte cryptographically random tokens"

  - id: race-condition
    symptom: "Token used twice simultaneously"
    cause: "No transaction around token validation and use"
    solution: "Use database transaction for atomic token validation and update"

validation:
  manual_test:
    - "Request password reset"
    - "Receive reset email"
    - "Click reset link"
    - "Set new password"
    - "Verify old password doesn't work"
    - "Verify new password works"
    - "Test expired link"
    - "Test used link"
