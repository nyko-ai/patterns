id: nextauth-google
version: "1.0.0"
updated_at: "2026-01-31"
author: "nyko-team"
status: beta

name: "NextAuth.js Google OAuth"
description: "Google OAuth authentication with NextAuth.js, Prisma adapter, and database sessions"

category: auth
tags:
  - nextauth
  - google
  - oauth
  - prisma
  - database-session
  - nextjs

difficulty: intermediate
time_estimate: "20-30 min"

stack:
  required:
    - name: "next"
      version: "^15.1.0"
      reason: "App Router with server components"
    - name: "next-auth"
      version: "^5.0.0-beta.25"
      reason: "Authentication library (Auth.js v5)"
    - name: "@prisma/client"
      version: "^6.0.0"
      reason: "Database ORM"
    - name: "prisma"
      version: "^6.0.0"
      reason: "Prisma CLI for migrations"
    - name: "@auth/prisma-adapter"
      version: "^2.7.4"
      reason: "NextAuth Prisma adapter for database sessions"

requires: []

enables:
  - nextauth-credentials

env_vars:
  required:
    - key: DATABASE_URL
      description: "PostgreSQL connection string"
      format: "postgresql://user:password@host:5432/database"
      where_to_find: "Your database provider dashboard"
    - key: AUTH_SECRET
      description: "NextAuth secret for encryption"
      format: "Random 32+ character string"
      where_to_find: "Generate with: openssl rand -base64 32"
    - key: AUTH_GOOGLE_ID
      description: "Google OAuth Client ID"
      format: "xxx.apps.googleusercontent.com"
      where_to_find: "Google Cloud Console > APIs & Services > Credentials"
    - key: AUTH_GOOGLE_SECRET
      description: "Google OAuth Client Secret"
      format: "GOCSPX-xxx"
      where_to_find: "Google Cloud Console > APIs & Services > Credentials"
  optional:
    - key: AUTH_URL
      description: "NextAuth base URL (auto-detected in production)"
      default: "http://localhost:3000"

external_setup:
  - service: "Google Cloud Console"
    url: "https://console.cloud.google.com/apis/credentials"
    steps:
      - "Create a new project or select existing"
      - "Go to APIs & Services > OAuth consent screen"
      - "Configure consent screen (External for public apps)"
      - "Add scopes: email, profile, openid"
      - "Go to Credentials > Create Credentials > OAuth client ID"
      - "Select 'Web application'"
      - "Add Authorized JavaScript origins: http://localhost:3000"
      - "Add Authorized redirect URI: http://localhost:3000/api/auth/callback/google"
      - "For production, add your domain URLs"
      - "Copy Client ID and Client Secret"

  - service: "Database Provider"
    url: "https://neon.tech or https://supabase.com"
    steps:
      - "Create a new PostgreSQL database"
      - "Copy the connection string"
      - "Add DATABASE_URL to your .env file"
      - "Run: npx prisma db push"

files:
  - path: "prisma/schema.prisma"
    action: create
    description: "Prisma schema with NextAuth models"
    priority: 1

  - path: "lib/prisma.ts"
    action: create
    description: "Prisma client singleton"
    priority: 2

  - path: "lib/auth.ts"
    action: create
    description: "NextAuth configuration with Google provider"
    priority: 3

  - path: "app/api/auth/[...nextauth]/route.ts"
    action: create
    description: "NextAuth API route handler"
    priority: 4

  - path: "app/login/page.tsx"
    action: create
    description: "Login page with Google button"
    priority: 5

  - path: "components/auth/google-sign-in-button.tsx"
    action: create
    description: "Google sign-in button component"
    priority: 6

  - path: "components/auth/sign-out-button.tsx"
    action: create
    description: "Sign out button component"
    priority: 7

  - path: "middleware.ts"
    action: create
    description: "Auth middleware for protected routes"
    priority: 8

code:
  prisma/schema.prisma: |
    generator client {
      provider = "prisma-client-js"
    }

    datasource db {
      provider = "postgresql"
      url      = env("DATABASE_URL")
    }

    model User {
      id            String    @id @default(cuid())
      name          String?
      email         String    @unique
      emailVerified DateTime?
      image         String?
      accounts      Account[]
      sessions      Session[]
      createdAt     DateTime  @default(now())
      updatedAt     DateTime  @updatedAt
    }

    model Account {
      userId            String
      type              String
      provider          String
      providerAccountId String
      refresh_token     String?
      access_token      String?
      expires_at        Int?
      token_type        String?
      scope             String?
      id_token          String?
      session_state     String?
      createdAt         DateTime @default(now())
      updatedAt         DateTime @updatedAt
      user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

      @@id([provider, providerAccountId])
    }

    model Session {
      sessionToken String   @unique
      userId       String
      expires      DateTime
      user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
      createdAt    DateTime @default(now())
      updatedAt    DateTime @updatedAt
    }

    model VerificationToken {
      identifier String
      token      String
      expires    DateTime

      @@id([identifier, token])
    }

  lib/prisma.ts: |
    import { PrismaClient } from "@prisma/client";

    const globalForPrisma = globalThis as unknown as {
      prisma: PrismaClient | undefined;
    };

    export const prisma = globalForPrisma.prisma ?? new PrismaClient();

    if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

  lib/auth.ts: |
    import NextAuth from "next-auth";
    import Google from "next-auth/providers/google";
    import { PrismaAdapter } from "@auth/prisma-adapter";
    import { prisma } from "@/lib/prisma";

    export const { handlers, auth, signIn, signOut } = NextAuth({
      adapter: PrismaAdapter(prisma),
      session: { strategy: "database" },
      pages: {
        signIn: "/login",
      },
      providers: [
        Google({
          clientId: process.env.AUTH_GOOGLE_ID!,
          clientSecret: process.env.AUTH_GOOGLE_SECRET!,
          authorization: {
            params: {
              prompt: "consent",
              access_type: "offline",
              response_type: "code",
            },
          },
        }),
      ],
      callbacks: {
        async session({ session, user }) {
          if (session.user) {
            session.user.id = user.id;
          }
          return session;
        },
      },
    });

  app/api/auth/[...nextauth]/route.ts: |
    import { handlers } from "@/lib/auth";

    export const { GET, POST } = handlers;

  app/login/page.tsx: |
    import { GoogleSignInButton } from "@/components/auth/google-sign-in-button";
    import { auth } from "@/lib/auth";
    import { redirect } from "next/navigation";

    export default async function LoginPage() {
      const session = await auth();

      if (session?.user) {
        redirect("/");
      }

      return (
        <div className="flex min-h-screen items-center justify-center">
          <div className="w-full max-w-sm space-y-6 p-8">
            <div className="text-center">
              <h1 className="text-2xl font-bold">Welcome back</h1>
              <p className="text-gray-500 mt-2">
                Sign in to your account to continue
              </p>
            </div>

            <GoogleSignInButton />

            <p className="text-center text-sm text-gray-500">
              By continuing, you agree to our Terms of Service and Privacy Policy.
            </p>
          </div>
        </div>
      );
    }

  components/auth/google-sign-in-button.tsx: |
    "use client";

    import { signIn } from "next-auth/react";
    import { useState } from "react";

    export function GoogleSignInButton() {
      const [isLoading, setIsLoading] = useState(false);

      const handleSignIn = async () => {
        setIsLoading(true);
        try {
          await signIn("google", { callbackUrl: "/" });
        } catch (error) {
          console.error("Error signing in with Google:", error);
          setIsLoading(false);
        }
      };

      return (
        <button
          onClick={handleSignIn}
          disabled={isLoading}
          className="flex w-full items-center justify-center gap-3 rounded-lg border border-gray-300 bg-white px-4 py-3 text-sm font-medium text-gray-700 shadow-sm transition-colors hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
        >
          <svg className="h-5 w-5" viewBox="0 0 24 24">
            <path
              fill="#4285F4"
              d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
            />
            <path
              fill="#34A853"
              d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
            />
            <path
              fill="#FBBC05"
              d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
            />
            <path
              fill="#EA4335"
              d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
            />
          </svg>
          {isLoading ? "Signing in..." : "Continue with Google"}
        </button>
      );
    }

  components/auth/sign-out-button.tsx: |
    "use client";

    import { signOut } from "next-auth/react";
    import { useState } from "react";

    interface SignOutButtonProps {
      className?: string;
    }

    export function SignOutButton({ className }: SignOutButtonProps) {
      const [isLoading, setIsLoading] = useState(false);

      const handleSignOut = async () => {
        setIsLoading(true);
        try {
          await signOut({ callbackUrl: "/login" });
        } catch (error) {
          console.error("Error signing out:", error);
          setIsLoading(false);
        }
      };

      return (
        <button
          onClick={handleSignOut}
          disabled={isLoading}
          className={className ?? "text-sm text-gray-600 hover:text-gray-900"}
        >
          {isLoading ? "Signing out..." : "Sign out"}
        </button>
      );
    }

  middleware.ts: |
    import { auth } from "@/lib/auth";
    import { NextResponse } from "next/server";

    export default auth((req) => {
      const isLoggedIn = !!req.auth;
      const isAuthPage = req.nextUrl.pathname.startsWith("/login");
      const isProtectedRoute = req.nextUrl.pathname.startsWith("/dashboard");

      // Redirect logged-in users away from auth pages
      if (isLoggedIn && isAuthPage) {
        return NextResponse.redirect(new URL("/", req.url));
      }

      // Redirect unauthenticated users to login
      if (!isLoggedIn && isProtectedRoute) {
        return NextResponse.redirect(new URL("/login", req.url));
      }

      return NextResponse.next();
    });

    export const config = {
      matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
    };

edge_cases:
  - id: redirect-uri-mismatch
    symptom: "Error 400: redirect_uri_mismatch"
    cause: "Callback URL not registered in Google Cloud Console"
    solution: |
      1. Go to Google Cloud Console > APIs & Services > Credentials
      2. Edit your OAuth 2.0 Client ID
      3. Add this exact URI to "Authorized redirect URIs":
         http://localhost:3000/api/auth/callback/google
      4. For production, add:
         https://yourdomain.com/api/auth/callback/google
      5. Save and wait a few minutes for changes to propagate

  - id: access-denied
    symptom: "Error: access_denied during OAuth flow"
    cause: "OAuth consent screen not configured or app not verified"
    solution: |
      1. Go to Google Cloud Console > OAuth consent screen
      2. Ensure all required fields are filled
      3. For testing, add your email to "Test users"
      4. For production, submit for verification
      5. Check that required scopes (email, profile) are added

  - id: session-not-persisting
    symptom: "User logged in but loses session after some time"
    cause: "Session expired in database"
    solution: |
      Database sessions expire based on the Session.expires field.
      By default, NextAuth sets this to 30 days. To customize:

      In lib/auth.ts, add to NextAuth config:
      session: {
        strategy: "database",
        maxAge: 30 * 24 * 60 * 60, // 30 days in seconds
      }

  - id: prisma-connection-error
    symptom: "Can't reach database server"
    cause: "DATABASE_URL incorrect or database not accessible"
    solution: |
      1. Verify DATABASE_URL is correct in .env
      2. Check database is running and accessible
      3. For serverless databases (Neon, Supabase), ensure connection pooling is enabled
      4. Try: npx prisma db push to test connection

validation:
  manual_test:
    - "Run: npx prisma db push"
    - "Start development server: npm run dev"
    - "Navigate to /login"
    - "Click 'Continue with Google'"
    - "Complete Google sign-in flow"
    - "Verify redirect to home page"
    - "Refresh page - should remain logged in"
    - "Check database Session table for new entry"
    - "Click sign out and verify redirect to /login"
