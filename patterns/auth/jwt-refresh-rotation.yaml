id: jwt-refresh-rotation
version: "1.0.0"
updated_at: "2026-01-31"
author: "nyko-team"
status: beta

name: "JWT Refresh Token Rotation"
description: "Secure JWT authentication with refresh token rotation"

category: auth
tags:
  - jwt
  - refresh-token
  - rotation
  - security
  - authentication

difficulty: advanced
time_estimate: "30-40 min"

stack:
  required:
    - name: "jsonwebtoken"
      version: "^9.0.3"
      reason: "JWT signing and verification"
    - name: "next"
      version: "^15.1.0"
      reason: "Next.js App Router"
    - name: "@prisma/client"
      version: "^7.3.0"
      reason: "Token storage"

requires: []

enables: []

env_vars:
  required:
    - key: JWT_ACCESS_SECRET
      description: "Secret for signing access tokens"
      format: "32+ character random string"
      where_to_find: "Generate with: openssl rand -hex 32"
    - key: JWT_REFRESH_SECRET
      description: "Secret for signing refresh tokens"
      format: "32+ character random string"
      where_to_find: "Generate with: openssl rand -hex 32"
  optional:
    - key: ACCESS_TOKEN_EXPIRY
      description: "Access token expiry time"
      default: "15m"
    - key: REFRESH_TOKEN_EXPIRY
      description: "Refresh token expiry time"
      default: "7d"

external_setup: []

files:
  - path: "prisma/schema.prisma"
    action: modify
    description: "Add RefreshToken model"
    priority: 1

  - path: "lib/jwt.ts"
    action: create
    description: "JWT utilities"
    priority: 2

  - path: "lib/auth/tokens.ts"
    action: create
    description: "Token management"
    priority: 3

  - path: "app/api/auth/refresh/route.ts"
    action: create
    description: "Token refresh endpoint"
    priority: 4

  - path: "middleware.ts"
    action: create
    description: "JWT verification middleware"
    priority: 5

code:
  prisma/schema.prisma: |
    // Add to existing schema.prisma

    model RefreshToken {
      id          String   @id @default(cuid())
      token       String   @unique
      userId      String
      familyId    String
      expiresAt   DateTime
      revokedAt   DateTime?
      replacedBy  String?
      userAgent   String?
      ipAddress   String?
      createdAt   DateTime @default(now())

      user User @relation(fields: [userId], references: [id], onDelete: Cascade)

      @@index([userId])
      @@index([familyId])
      @@index([token])
    }

  lib/jwt.ts: |
    import jwt from "jsonwebtoken";

    const ACCESS_SECRET = process.env.JWT_ACCESS_SECRET!;
    const REFRESH_SECRET = process.env.JWT_REFRESH_SECRET!;
    const ACCESS_EXPIRY = process.env.ACCESS_TOKEN_EXPIRY || "15m";
    const REFRESH_EXPIRY = process.env.REFRESH_TOKEN_EXPIRY || "7d";

    export interface AccessTokenPayload {
      userId: string;
      email: string;
      role?: string;
    }

    export interface RefreshTokenPayload {
      userId: string;
      tokenId: string;
      familyId: string;
    }

    export function signAccessToken(payload: AccessTokenPayload): string {
      return jwt.sign(payload, ACCESS_SECRET, {
        expiresIn: ACCESS_EXPIRY,
        algorithm: "HS256",
      });
    }

    export function signRefreshToken(payload: RefreshTokenPayload): string {
      return jwt.sign(payload, REFRESH_SECRET, {
        expiresIn: REFRESH_EXPIRY,
        algorithm: "HS256",
      });
    }

    export function verifyAccessToken(token: string): AccessTokenPayload | null {
      try {
        return jwt.verify(token, ACCESS_SECRET) as AccessTokenPayload;
      } catch {
        return null;
      }
    }

    export function verifyRefreshToken(token: string): RefreshTokenPayload | null {
      try {
        return jwt.verify(token, REFRESH_SECRET) as RefreshTokenPayload;
      } catch {
        return null;
      }
    }

    export function decodeToken<T>(token: string): T | null {
      try {
        return jwt.decode(token) as T;
      } catch {
        return null;
      }
    }

    export function getTokenExpiry(expiresIn: string): Date {
      const units: Record<string, number> = {
        s: 1000,
        m: 60 * 1000,
        h: 60 * 60 * 1000,
        d: 24 * 60 * 60 * 1000,
      };

      const match = expiresIn.match(/^(\d+)([smhd])$/);
      if (!match) throw new Error("Invalid expiry format");

      const [, value, unit] = match;
      return new Date(Date.now() + parseInt(value) * units[unit]);
    }

  lib/auth/tokens.ts: |
    import { prisma } from "@/lib/prisma";
    import {
      signAccessToken,
      signRefreshToken,
      verifyRefreshToken,
      getTokenExpiry,
      type AccessTokenPayload,
    } from "@/lib/jwt";
    import crypto from "crypto";

    const REFRESH_EXPIRY = process.env.REFRESH_TOKEN_EXPIRY || "7d";

    export async function createTokenPair(
      user: { id: string; email: string; role?: string },
      metadata?: { userAgent?: string; ipAddress?: string }
    ) {
      const familyId = crypto.randomUUID();

      const refreshTokenRecord = await prisma.refreshToken.create({
        data: {
          token: crypto.randomUUID(),
          userId: user.id,
          familyId,
          expiresAt: getTokenExpiry(REFRESH_EXPIRY),
          userAgent: metadata?.userAgent,
          ipAddress: metadata?.ipAddress,
        },
      });

      const accessToken = signAccessToken({
        userId: user.id,
        email: user.email,
        role: user.role,
      });

      const refreshToken = signRefreshToken({
        userId: user.id,
        tokenId: refreshTokenRecord.id,
        familyId,
      });

      return { accessToken, refreshToken };
    }

    export async function rotateRefreshToken(
      oldRefreshToken: string,
      metadata?: { userAgent?: string; ipAddress?: string }
    ): Promise<{ accessToken: string; refreshToken: string } | null> {
      const payload = verifyRefreshToken(oldRefreshToken);
      if (!payload) return null;

      const existingToken = await prisma.refreshToken.findFirst({
        where: {
          id: payload.tokenId,
          familyId: payload.familyId,
        },
        include: { user: true },
      });

      if (!existingToken) return null;

      // Token reuse detection - revoke entire family
      if (existingToken.revokedAt) {
        await prisma.refreshToken.updateMany({
          where: { familyId: payload.familyId },
          data: { revokedAt: new Date() },
        });
        return null;
      }

      if (existingToken.expiresAt < new Date()) {
        return null;
      }

      // Revoke old token and create new one
      const newTokenRecord = await prisma.$transaction(async (tx) => {
        await tx.refreshToken.update({
          where: { id: existingToken.id },
          data: { revokedAt: new Date() },
        });

        return tx.refreshToken.create({
          data: {
            token: crypto.randomUUID(),
            userId: existingToken.userId,
            familyId: payload.familyId,
            expiresAt: getTokenExpiry(REFRESH_EXPIRY),
            userAgent: metadata?.userAgent,
            ipAddress: metadata?.ipAddress,
          },
        });
      });

      // Update old token with reference to new one
      await prisma.refreshToken.update({
        where: { id: existingToken.id },
        data: { replacedBy: newTokenRecord.id },
      });

      const accessToken = signAccessToken({
        userId: existingToken.user.id,
        email: existingToken.user.email,
      });

      const refreshToken = signRefreshToken({
        userId: existingToken.userId,
        tokenId: newTokenRecord.id,
        familyId: payload.familyId,
      });

      return { accessToken, refreshToken };
    }

    export async function revokeRefreshTokenFamily(familyId: string) {
      return prisma.refreshToken.updateMany({
        where: { familyId },
        data: { revokedAt: new Date() },
      });
    }

    export async function revokeAllUserTokens(userId: string) {
      return prisma.refreshToken.updateMany({
        where: { userId },
        data: { revokedAt: new Date() },
      });
    }

    export async function cleanupExpiredTokens() {
      return prisma.refreshToken.deleteMany({
        where: {
          OR: [
            { expiresAt: { lt: new Date() } },
            {
              revokedAt: { not: null },
              createdAt: { lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) },
            },
          ],
        },
      });
    }

  app/api/auth/refresh/route.ts: |
    import { NextRequest, NextResponse } from "next/server";
    import { rotateRefreshToken } from "@/lib/auth/tokens";
    import { cookies } from "next/headers";

    export async function POST(request: NextRequest) {
      const cookieStore = await cookies();
      const refreshToken =
        cookieStore.get("refresh_token")?.value ||
        request.headers.get("x-refresh-token");

      if (!refreshToken) {
        return NextResponse.json(
          { error: "Refresh token required" },
          { status: 401 }
        );
      }

      const tokens = await rotateRefreshToken(refreshToken, {
        userAgent: request.headers.get("user-agent") || undefined,
        ipAddress: request.headers.get("x-forwarded-for")?.split(",")[0],
      });

      if (!tokens) {
        const response = NextResponse.json(
          { error: "Invalid or expired refresh token" },
          { status: 401 }
        );

        response.cookies.delete("refresh_token");
        return response;
      }

      const response = NextResponse.json({
        accessToken: tokens.accessToken,
      });

      response.cookies.set("refresh_token", tokens.refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        path: "/",
        maxAge: 7 * 24 * 60 * 60,
      });

      return response;
    }

  middleware.ts: |
    import { NextRequest, NextResponse } from "next/server";
    import { verifyAccessToken } from "@/lib/jwt";

    const protectedPaths = ["/api/protected", "/dashboard"];
    const publicPaths = ["/api/auth", "/login", "/register"];

    export function middleware(request: NextRequest) {
      const { pathname } = request.nextUrl;

      const isProtected = protectedPaths.some((path) => pathname.startsWith(path));
      const isPublic = publicPaths.some((path) => pathname.startsWith(path));

      if (!isProtected || isPublic) {
        return NextResponse.next();
      }

      const authHeader = request.headers.get("authorization");
      const token = authHeader?.replace("Bearer ", "");

      if (!token) {
        return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      }

      const payload = verifyAccessToken(token);

      if (!payload) {
        return NextResponse.json(
          { error: "Invalid or expired token" },
          { status: 401 }
        );
      }

      const requestHeaders = new Headers(request.headers);
      requestHeaders.set("x-user-id", payload.userId);
      requestHeaders.set("x-user-email", payload.email);

      return NextResponse.next({
        request: { headers: requestHeaders },
      });
    }

    export const config = {
      matcher: ["/api/:path*", "/dashboard/:path*"],
    };

edge_cases:
  - id: token-reuse-attack
    symptom: "Refresh token used twice"
    cause: "Token theft or replay attack"
    solution: "Revoke entire token family when reuse detected"

  - id: clock-skew
    symptom: "Token rejected as expired prematurely"
    cause: "Server clock out of sync"
    solution: "Use NTP sync, add small buffer to expiry checks"

  - id: concurrent-refresh
    symptom: "Race condition during token rotation"
    cause: "Multiple refresh requests at same time"
    solution: "Use database transactions, implement request queuing"

  - id: token-storage
    symptom: "XSS can steal tokens"
    cause: "Access token stored in localStorage"
    solution: "Store refresh token in httpOnly cookie, access token in memory only"

validation:
  manual_test:
    - "Login and receive token pair"
    - "Use access token for protected routes"
    - "Refresh token before expiry"
    - "Verify old refresh token is invalid"
    - "Test token reuse detection"
    - "Logout and verify tokens revoked"
