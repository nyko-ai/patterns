id: structured-data
name: JSON-LD Structured Data
description: Schema.org JSON-LD structured data for SEO enhancement
category: seo
tags:
  - seo
  - json-ld
  - schema.org
  - structured-data
  - rich-snippets
dependencies: []
files:
  - path: lib/seo/structured-data.ts
    description: Structured data generators
    content: |
      const BASE_URL = process.env.NEXT_PUBLIC_SITE_URL || 'https://example.com';

      // Organization schema
      export function generateOrganizationSchema({
        name,
        description,
        logo,
        url = BASE_URL,
        sameAs = [],
      }: {
        name: string;
        description: string;
        logo: string;
        url?: string;
        sameAs?: string[];
      }) {
        return {
          '@context': 'https://schema.org',
          '@type': 'Organization',
          name,
          description,
          url,
          logo: {
            '@type': 'ImageObject',
            url: logo.startsWith('http') ? logo : `${url}${logo}`,
          },
          sameAs,
        };
      }

      // WebSite schema with search action
      export function generateWebSiteSchema({
        name,
        description,
        url = BASE_URL,
        searchPath = '/search?q=',
      }: {
        name: string;
        description: string;
        url?: string;
        searchPath?: string;
      }) {
        return {
          '@context': 'https://schema.org',
          '@type': 'WebSite',
          name,
          description,
          url,
          potentialAction: {
            '@type': 'SearchAction',
            target: `${url}${searchPath}{search_term_string}`,
            'query-input': 'required name=search_term_string',
          },
        };
      }

      // Article schema
      export function generateArticleSchema({
        title,
        description,
        slug,
        image,
        datePublished,
        dateModified,
        author,
        publisher,
      }: {
        title: string;
        description: string;
        slug: string;
        image: string;
        datePublished: string;
        dateModified?: string;
        author: { name: string; url?: string };
        publisher: { name: string; logo: string };
      }) {
        return {
          '@context': 'https://schema.org',
          '@type': 'Article',
          headline: title,
          description,
          image: image.startsWith('http') ? image : `${BASE_URL}${image}`,
          datePublished,
          dateModified: dateModified || datePublished,
          url: `${BASE_URL}/blog/${slug}`,
          author: {
            '@type': 'Person',
            name: author.name,
            ...(author.url && { url: author.url }),
          },
          publisher: {
            '@type': 'Organization',
            name: publisher.name,
            logo: {
              '@type': 'ImageObject',
              url: publisher.logo.startsWith('http')
                ? publisher.logo
                : `${BASE_URL}${publisher.logo}`,
            },
          },
          mainEntityOfPage: {
            '@type': 'WebPage',
            '@id': `${BASE_URL}/blog/${slug}`,
          },
        };
      }

      // Product schema
      export function generateProductSchema({
        name,
        description,
        slug,
        image,
        price,
        currency = 'USD',
        availability = 'InStock',
        brand,
        sku,
        rating,
        reviewCount,
      }: {
        name: string;
        description: string;
        slug: string;
        image: string;
        price: number;
        currency?: string;
        availability?: 'InStock' | 'OutOfStock' | 'PreOrder';
        brand?: string;
        sku?: string;
        rating?: number;
        reviewCount?: number;
      }) {
        const schema: Record<string, any> = {
          '@context': 'https://schema.org',
          '@type': 'Product',
          name,
          description,
          image: image.startsWith('http') ? image : `${BASE_URL}${image}`,
          url: `${BASE_URL}/products/${slug}`,
          offers: {
            '@type': 'Offer',
            price,
            priceCurrency: currency,
            availability: `https://schema.org/${availability}`,
            url: `${BASE_URL}/products/${slug}`,
          },
        };

        if (brand) {
          schema.brand = { '@type': 'Brand', name: brand };
        }

        if (sku) {
          schema.sku = sku;
        }

        if (rating && reviewCount) {
          schema.aggregateRating = {
            '@type': 'AggregateRating',
            ratingValue: rating,
            reviewCount,
          };
        }

        return schema;
      }

      // Breadcrumb schema
      export function generateBreadcrumbSchema(
        items: Array<{ name: string; url: string }>
      ) {
        return {
          '@context': 'https://schema.org',
          '@type': 'BreadcrumbList',
          itemListElement: items.map((item, index) => ({
            '@type': 'ListItem',
            position: index + 1,
            name: item.name,
            item: item.url.startsWith('http') ? item.url : `${BASE_URL}${item.url}`,
          })),
        };
      }

      // FAQ schema
      export function generateFAQSchema(
        questions: Array<{ question: string; answer: string }>
      ) {
        return {
          '@context': 'https://schema.org',
          '@type': 'FAQPage',
          mainEntity: questions.map((q) => ({
            '@type': 'Question',
            name: q.question,
            acceptedAnswer: {
              '@type': 'Answer',
              text: q.answer,
            },
          })),
        };
      }

      // Local Business schema
      export function generateLocalBusinessSchema({
        name,
        description,
        image,
        address,
        geo,
        phone,
        openingHours,
        priceRange,
      }: {
        name: string;
        description: string;
        image: string;
        address: {
          street: string;
          city: string;
          state: string;
          postalCode: string;
          country: string;
        };
        geo: { latitude: number; longitude: number };
        phone: string;
        openingHours: string[];
        priceRange?: string;
      }) {
        return {
          '@context': 'https://schema.org',
          '@type': 'LocalBusiness',
          name,
          description,
          image: image.startsWith('http') ? image : `${BASE_URL}${image}`,
          address: {
            '@type': 'PostalAddress',
            streetAddress: address.street,
            addressLocality: address.city,
            addressRegion: address.state,
            postalCode: address.postalCode,
            addressCountry: address.country,
          },
          geo: {
            '@type': 'GeoCoordinates',
            latitude: geo.latitude,
            longitude: geo.longitude,
          },
          telephone: phone,
          openingHoursSpecification: openingHours.map((hours) => ({
            '@type': 'OpeningHoursSpecification',
            ...parseOpeningHours(hours),
          })),
          ...(priceRange && { priceRange }),
        };
      }

      function parseOpeningHours(hours: string) {
        // Format: "Mon-Fri 09:00-18:00"
        const [days, times] = hours.split(' ');
        const [open, close] = times.split('-');
        return {
          dayOfWeek: days.split('-'),
          opens: open,
          closes: close,
        };
      }

  - path: components/seo/structured-data.tsx
    description: React component for structured data
    content: |
      interface StructuredDataProps {
        data: Record<string, any> | Record<string, any>[];
      }

      export function StructuredData({ data }: StructuredDataProps) {
        const jsonLd = Array.isArray(data)
          ? data.map((d) => JSON.stringify(d)).join('')
          : JSON.stringify(data);

        return (
          <script
            type="application/ld+json"
            dangerouslySetInnerHTML={{ __html: jsonLd }}
          />
        );
      }

      // Convenience components for common schemas
      export function OrganizationSchema(
        props: Parameters<typeof import('@/lib/seo/structured-data').generateOrganizationSchema>[0]
      ) {
        const { generateOrganizationSchema } = require('@/lib/seo/structured-data');
        return <StructuredData data={generateOrganizationSchema(props)} />;
      }

      export function ArticleSchema(
        props: Parameters<typeof import('@/lib/seo/structured-data').generateArticleSchema>[0]
      ) {
        const { generateArticleSchema } = require('@/lib/seo/structured-data');
        return <StructuredData data={generateArticleSchema(props)} />;
      }

      export function ProductSchema(
        props: Parameters<typeof import('@/lib/seo/structured-data').generateProductSchema>[0]
      ) {
        const { generateProductSchema } = require('@/lib/seo/structured-data');
        return <StructuredData data={generateProductSchema(props)} />;
      }

      export function BreadcrumbSchema({
        items,
      }: {
        items: Array<{ name: string; url: string }>;
      }) {
        const { generateBreadcrumbSchema } = require('@/lib/seo/structured-data');
        return <StructuredData data={generateBreadcrumbSchema(items)} />;
      }

      export function FAQSchema({
        questions,
      }: {
        questions: Array<{ question: string; answer: string }>;
      }) {
        const { generateFAQSchema } = require('@/lib/seo/structured-data');
        return <StructuredData data={generateFAQSchema(questions)} />;
      }

  - path: app/blog/[slug]/page.tsx
    description: Example usage in a blog page
    content: |
      import { notFound } from 'next/navigation';
      import { StructuredData } from '@/components/seo/structured-data';
      import { generateArticleSchema, generateBreadcrumbSchema } from '@/lib/seo/structured-data';

      async function getArticle(slug: string) {
        // Fetch article from your data source
        return {
          title: 'Example Article',
          description: 'This is an example article',
          content: 'Article content here...',
          image: '/blog/example.jpg',
          publishedAt: '2024-01-15T10:00:00Z',
          updatedAt: '2024-01-20T15:00:00Z',
          author: { name: 'John Doe', url: 'https://johndoe.com' },
        };
      }

      interface Props {
        params: Promise<{ slug: string }>;
      }

      export default async function ArticlePage({ params }: Props) {
        const { slug } = await params;
        const article = await getArticle(slug);

        if (!article) {
          notFound();
        }

        const articleSchema = generateArticleSchema({
          title: article.title,
          description: article.description,
          slug,
          image: article.image,
          datePublished: article.publishedAt,
          dateModified: article.updatedAt,
          author: article.author,
          publisher: { name: 'My Site', logo: '/logo.png' },
        });

        const breadcrumbSchema = generateBreadcrumbSchema([
          { name: 'Home', url: '/' },
          { name: 'Blog', url: '/blog' },
          { name: article.title, url: `/blog/${slug}` },
        ]);

        return (
          <>
            <StructuredData data={[articleSchema, breadcrumbSchema]} />
            <article>
              <h1>{article.title}</h1>
              <p>{article.content}</p>
            </article>
          </>
        );
      }

external_setup:
  - step: Set NEXT_PUBLIC_SITE_URL
    details: Add your production URL to .env.local
  - step: Test with Google Rich Results Test
    details: Use https://search.google.com/test/rich-results to validate markup
  - step: Add to page layouts
    details: Include StructuredData component in relevant pages

edge_cases:
  - case: Missing required fields
    solution: Validate inputs before generating schema, provide sensible defaults
  - case: Invalid URLs
    solution: Ensure all URLs are absolute, prepend BASE_URL if relative
  - case: Multiple schemas per page
    solution: Pass array to StructuredData component, renders multiple script tags
  - case: Dynamic content
    solution: Generate schema server-side in page components, not in layouts
  - case: Testing locally
    solution: Use ngrok or similar to test with Google's validator
