id: multi-tenancy
version: "1.0.0"
updated_at: "2026-01-31"
author: "nyko-team"
status: beta

name: "Row-Based Multi-Tenancy"
description: "Implement multi-tenant architecture with row-level security and tenant isolation"

category: database
tags:
  - postgres
  - multi-tenancy
  - rls
  - saas
  - isolation

difficulty: advanced
time_estimate: "40-50 min"

stack:
  required:
    - name: "next"
      version: "^15.1.0"
      reason: "App Router"
    - name: "@supabase/supabase-js"
      version: "^2.93.0"
      reason: "Supabase client with RLS"

requires:
  - supabase-client-nextjs
  - supabase-rls-policies

enables: []

env_vars:
  required:
    - key: NEXT_PUBLIC_SUPABASE_URL
      description: "Supabase project URL"
      format: "https://xxx.supabase.co"
      where_to_find: "Supabase Dashboard > Settings > API"
    - key: NEXT_PUBLIC_SUPABASE_ANON_KEY
      description: "Supabase anonymous key"
      format: "eyJ..."
      where_to_find: "Supabase Dashboard > Settings > API"

external_setup:
  - service: "Supabase"
    url: "https://supabase.com/dashboard"
    steps:
      - "Create Supabase project"
      - "Run the multi-tenancy migration"
      - "Configure custom claims for tenant"
      - "Set up tenant provisioning flow"
      - "Test tenant isolation"

files:
  - path: "supabase/migrations/001_multi_tenancy.sql"
    action: create
    description: "Multi-tenancy schema and RLS policies"
    priority: 1

  - path: "lib/tenant/tenant-context.ts"
    action: create
    description: "Tenant context management"
    priority: 2

  - path: "lib/tenant/tenant-middleware.ts"
    action: create
    description: "Tenant resolution middleware"
    priority: 3

  - path: "app/api/tenants/route.ts"
    action: create
    description: "Tenant management API"
    priority: 4

code:
  supabase/migrations/001_multi_tenancy.sql: |
    -- Create tenants table
    CREATE TABLE IF NOT EXISTS tenants (
      id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
      name text NOT NULL,
      slug text UNIQUE NOT NULL,
      settings jsonb DEFAULT '{}',
      plan text DEFAULT 'free' CHECK (plan IN ('free', 'pro', 'enterprise')),
      status text DEFAULT 'active' CHECK (status IN ('active', 'suspended', 'deleted')),
      created_at timestamptz DEFAULT now(),
      updated_at timestamptz DEFAULT now()
    );

    -- Create tenant_members table (user-tenant relationship)
    CREATE TABLE IF NOT EXISTS tenant_members (
      id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
      tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
      user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
      role text DEFAULT 'member' CHECK (role IN ('owner', 'admin', 'member', 'viewer')),
      created_at timestamptz DEFAULT now(),
      UNIQUE(tenant_id, user_id)
    );

    -- Create indexes
    CREATE INDEX IF NOT EXISTS tenant_members_user_idx ON tenant_members(user_id);
    CREATE INDEX IF NOT EXISTS tenant_members_tenant_idx ON tenant_members(tenant_id);
    CREATE INDEX IF NOT EXISTS tenants_slug_idx ON tenants(slug);

    -- Function to get user's current tenant from JWT
    CREATE OR REPLACE FUNCTION get_current_tenant_id()
    RETURNS uuid
    LANGUAGE sql
    STABLE
    AS $$
      SELECT COALESCE(
        -- First try to get from custom claim
        (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid,
        -- Fallback to user's primary tenant
        (SELECT tenant_id FROM tenant_members WHERE user_id = auth.uid() LIMIT 1)
      );
    $$;

    -- Function to check if user belongs to a tenant
    CREATE OR REPLACE FUNCTION user_belongs_to_tenant(check_tenant_id uuid)
    RETURNS boolean
    LANGUAGE sql
    STABLE
    SECURITY DEFINER
    AS $$
      SELECT EXISTS (
        SELECT 1 FROM tenant_members
        WHERE user_id = auth.uid() AND tenant_id = check_tenant_id
      );
    $$;

    -- Function to check user's role in a tenant
    CREATE OR REPLACE FUNCTION get_user_tenant_role(check_tenant_id uuid)
    RETURNS text
    LANGUAGE sql
    STABLE
    SECURITY DEFINER
    AS $$
      SELECT role FROM tenant_members
      WHERE user_id = auth.uid() AND tenant_id = check_tenant_id;
    $$;

    -- Enable RLS on tenants
    ALTER TABLE tenants ENABLE ROW LEVEL SECURITY;

    -- Tenant policies
    CREATE POLICY "Users can view their tenants"
    ON tenants FOR SELECT
    USING (user_belongs_to_tenant(id));

    CREATE POLICY "Owners and admins can update tenant"
    ON tenants FOR UPDATE
    USING (get_user_tenant_role(id) IN ('owner', 'admin'));

    -- Enable RLS on tenant_members
    ALTER TABLE tenant_members ENABLE ROW LEVEL SECURITY;

    -- Tenant members policies
    CREATE POLICY "Members can view tenant members"
    ON tenant_members FOR SELECT
    USING (user_belongs_to_tenant(tenant_id));

    CREATE POLICY "Owners and admins can manage members"
    ON tenant_members FOR ALL
    USING (get_user_tenant_role(tenant_id) IN ('owner', 'admin'));

    -- Example: Create a tenant-scoped table
    CREATE TABLE IF NOT EXISTS projects (
      id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
      tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
      name text NOT NULL,
      description text,
      created_by uuid REFERENCES auth.users(id),
      created_at timestamptz DEFAULT now(),
      updated_at timestamptz DEFAULT now()
    );

    CREATE INDEX IF NOT EXISTS projects_tenant_idx ON projects(tenant_id);

    -- Enable RLS on projects
    ALTER TABLE projects ENABLE ROW LEVEL SECURITY;

    -- Project policies - tenant isolation
    CREATE POLICY "Users can view tenant projects"
    ON projects FOR SELECT
    USING (user_belongs_to_tenant(tenant_id));

    CREATE POLICY "Members can create projects"
    ON projects FOR INSERT
    WITH CHECK (
      user_belongs_to_tenant(tenant_id) AND
      get_user_tenant_role(tenant_id) IN ('owner', 'admin', 'member')
    );

    CREATE POLICY "Members can update projects"
    ON projects FOR UPDATE
    USING (
      user_belongs_to_tenant(tenant_id) AND
      get_user_tenant_role(tenant_id) IN ('owner', 'admin', 'member')
    );

    CREATE POLICY "Admins can delete projects"
    ON projects FOR DELETE
    USING (get_user_tenant_role(tenant_id) IN ('owner', 'admin'));

    -- Function to auto-set tenant_id on insert
    CREATE OR REPLACE FUNCTION set_tenant_id()
    RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    BEGIN
      IF NEW.tenant_id IS NULL THEN
        NEW.tenant_id := get_current_tenant_id();
      END IF;

      IF NEW.tenant_id IS NULL THEN
        RAISE EXCEPTION 'No tenant context available';
      END IF;

      RETURN NEW;
    END;
    $$;

    -- Apply auto-tenant trigger to projects
    CREATE TRIGGER set_project_tenant
    BEFORE INSERT ON projects
    FOR EACH ROW EXECUTE FUNCTION set_tenant_id();

    -- Function to create a new tenant with owner
    CREATE OR REPLACE FUNCTION create_tenant(
      tenant_name text,
      tenant_slug text,
      owner_user_id uuid DEFAULT auth.uid()
    )
    RETURNS uuid
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
    DECLARE
      new_tenant_id uuid;
    BEGIN
      -- Create tenant
      INSERT INTO tenants (name, slug)
      VALUES (tenant_name, tenant_slug)
      RETURNING id INTO new_tenant_id;

      -- Add creator as owner
      INSERT INTO tenant_members (tenant_id, user_id, role)
      VALUES (new_tenant_id, owner_user_id, 'owner');

      RETURN new_tenant_id;
    END;
    $$;

  lib/tenant/tenant-context.ts: |
    import { createClient } from "@/lib/supabase/client";
    import { createServerClient } from "@/lib/supabase/server";

    export interface Tenant {
      id: string;
      name: string;
      slug: string;
      settings: Record<string, unknown>;
      plan: "free" | "pro" | "enterprise";
      status: "active" | "suspended" | "deleted";
    }

    export interface TenantMember {
      id: string;
      tenant_id: string;
      user_id: string;
      role: "owner" | "admin" | "member" | "viewer";
    }

    /**
     * Get current user's tenants (client-side)
     */
    export async function getUserTenants(): Promise<Tenant[]> {
      const supabase = createClient();

      const { data: memberships, error } = await supabase
        .from("tenant_members")
        .select("tenant_id, role, tenants(*)")
        .order("created_at", { ascending: false });

      if (error || !memberships) {
        console.error("Failed to get tenants:", error);
        return [];
      }

      return memberships.map((m) => m.tenants as unknown as Tenant);
    }

    /**
     * Get tenant by slug
     */
    export async function getTenantBySlug(slug: string): Promise<Tenant | null> {
      const supabase = createClient();

      const { data, error } = await supabase
        .from("tenants")
        .select("*")
        .eq("slug", slug)
        .single();

      if (error || !data) {
        return null;
      }

      return data as Tenant;
    }

    /**
     * Get current tenant from session (server-side)
     */
    export async function getCurrentTenant(): Promise<Tenant | null> {
      const supabase = await createServerClient();

      const { data: { user } } = await supabase.auth.getUser();

      if (!user) return null;

      // Get tenant from app_metadata or first available
      const tenantId = user.app_metadata?.tenant_id;

      if (tenantId) {
        const { data } = await supabase
          .from("tenants")
          .select("*")
          .eq("id", tenantId)
          .single();

        return data as Tenant | null;
      }

      // Fallback to first tenant
      const { data: membership } = await supabase
        .from("tenant_members")
        .select("tenants(*)")
        .eq("user_id", user.id)
        .limit(1)
        .single();

      return (membership?.tenants as unknown as Tenant) || null;
    }

    /**
     * Switch user's active tenant
     */
    export async function switchTenant(tenantId: string): Promise<boolean> {
      const supabase = createClient();

      const { error } = await supabase.auth.updateUser({
        data: { tenant_id: tenantId },
      });

      if (error) {
        console.error("Failed to switch tenant:", error);
        return false;
      }

      return true;
    }

    /**
     * Get user's role in a tenant
     */
    export async function getUserTenantRole(
      tenantId: string
    ): Promise<TenantMember["role"] | null> {
      const supabase = createClient();

      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return null;

      const { data } = await supabase
        .from("tenant_members")
        .select("role")
        .eq("tenant_id", tenantId)
        .eq("user_id", user.id)
        .single();

      return data?.role || null;
    }

    /**
     * Check if user has permission
     */
    export function hasPermission(
      role: TenantMember["role"] | null,
      requiredRole: TenantMember["role"]
    ): boolean {
      if (!role) return false;

      const hierarchy: Record<TenantMember["role"], number> = {
        owner: 4,
        admin: 3,
        member: 2,
        viewer: 1,
      };

      return hierarchy[role] >= hierarchy[requiredRole];
    }

  lib/tenant/tenant-middleware.ts: |
    import { NextRequest, NextResponse } from "next/server";
    import { createServerClient } from "@supabase/ssr";

    /**
     * Middleware to resolve tenant from subdomain or path
     */
    export function createTenantMiddleware(options: {
      subdomainMode?: boolean;
      pathPrefix?: string;
    } = {}) {
      const { subdomainMode = false, pathPrefix = "/t" } = options;

      return async function tenantMiddleware(request: NextRequest) {
        let tenantSlug: string | null = null;

        if (subdomainMode) {
          // Extract from subdomain: tenant.app.com
          const hostname = request.headers.get("host") || "";
          const parts = hostname.split(".");

          if (parts.length >= 3) {
            tenantSlug = parts[0];
          }
        } else {
          // Extract from path: /t/tenant-slug/...
          const path = request.nextUrl.pathname;

          if (path.startsWith(pathPrefix + "/")) {
            const parts = path.split("/");
            tenantSlug = parts[2] || null;
          }
        }

        if (!tenantSlug) {
          return NextResponse.next();
        }

        // Validate tenant exists
        const supabase = createServerClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL!,
          process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
          {
            cookies: {
              getAll: () => request.cookies.getAll(),
              setAll: () => {},
            },
          }
        );

        const { data: tenant } = await supabase
          .from("tenants")
          .select("id, status")
          .eq("slug", tenantSlug)
          .single();

        if (!tenant) {
          return NextResponse.redirect(new URL("/404", request.url));
        }

        if (tenant.status !== "active") {
          return NextResponse.redirect(new URL("/tenant-suspended", request.url));
        }

        // Add tenant info to headers for downstream use
        const response = NextResponse.next();
        response.headers.set("x-tenant-id", tenant.id);
        response.headers.set("x-tenant-slug", tenantSlug);

        return response;
      };
    }

    /**
     * Get tenant from request headers (set by middleware)
     */
    export function getTenantFromHeaders(headers: Headers): {
      tenantId: string | null;
      tenantSlug: string | null;
    } {
      return {
        tenantId: headers.get("x-tenant-id"),
        tenantSlug: headers.get("x-tenant-slug"),
      };
    }

  app/api/tenants/route.ts: |
    import { NextRequest, NextResponse } from "next/server";
    import { createServerClient } from "@/lib/supabase/server";

    export async function GET() {
      try {
        const supabase = await createServerClient();

        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
          return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }

        const { data: memberships, error } = await supabase
          .from("tenant_members")
          .select(`
            role,
            tenants (
              id,
              name,
              slug,
              plan,
              status
            )
          `)
          .eq("user_id", user.id);

        if (error) {
          return NextResponse.json({ error: error.message }, { status: 500 });
        }

        const tenants = memberships?.map((m) => ({
          ...m.tenants,
          role: m.role,
        })) || [];

        return NextResponse.json({ tenants });
      } catch (error) {
        return NextResponse.json(
          { error: "Failed to fetch tenants" },
          { status: 500 }
        );
      }
    }

    export async function POST(request: NextRequest) {
      try {
        const supabase = await createServerClient();

        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
          return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }

        const body = await request.json();
        const { name, slug } = body;

        if (!name || !slug) {
          return NextResponse.json(
            { error: "Name and slug are required" },
            { status: 400 }
          );
        }

        // Validate slug format
        const slugRegex = /^[a-z0-9-]+$/;
        if (!slugRegex.test(slug)) {
          return NextResponse.json(
            { error: "Slug must be lowercase alphanumeric with hyphens" },
            { status: 400 }
          );
        }

        // Create tenant using the database function
        const { data, error } = await supabase.rpc("create_tenant", {
          tenant_name: name,
          tenant_slug: slug,
          owner_user_id: user.id,
        });

        if (error) {
          if (error.message.includes("duplicate")) {
            return NextResponse.json(
              { error: "Slug already taken" },
              { status: 409 }
            );
          }
          return NextResponse.json({ error: error.message }, { status: 500 });
        }

        // Update user's active tenant
        await supabase.auth.updateUser({
          data: { tenant_id: data },
        });

        return NextResponse.json({
          success: true,
          tenantId: data,
        });
      } catch (error) {
        return NextResponse.json(
          { error: "Failed to create tenant" },
          { status: 500 }
        );
      }
    }

edge_cases:
  - id: orphaned-data
    symptom: "Data visible after user removed from tenant"
    cause: "RLS policies not properly checking membership"
    solution: |
      Ensure all tenant-scoped tables use user_belongs_to_tenant():

      CREATE POLICY "tenant_isolation"
      ON your_table FOR ALL
      USING (user_belongs_to_tenant(tenant_id));

      And invalidate any caches when membership changes.

  - id: cross-tenant-queries
    symptom: "Queries return data from multiple tenants"
    cause: "Missing tenant_id filter or RLS disabled"
    solution: |
      1. Verify RLS is enabled:
         ALTER TABLE your_table ENABLE ROW LEVEL SECURITY;

      2. Force RLS for table owners:
         ALTER TABLE your_table FORCE ROW LEVEL SECURITY;

      3. Always include tenant_id in queries as backup.

  - id: tenant-switching
    symptom: "User sees stale data after switching tenant"
    cause: "Client-side caching or stale JWT"
    solution: |
      1. Refresh the session after switching:
         await supabase.auth.refreshSession();

      2. Clear client-side caches:
         queryClient.invalidateQueries();

      3. Use server-side rendering for tenant-specific pages.

  - id: deleted-tenant
    symptom: "Errors when accessing deleted tenant"
    cause: "Stale tenant references"
    solution: |
      Handle tenant deletion gracefully:

      1. Check tenant status in middleware
      2. Redirect to tenant selection on 'deleted' status
      3. Clear tenant_id from user metadata on deletion

validation:
  manual_test:
    - "Run the migration"
    - "Create a tenant with the API"
    - "Verify owner can access tenant data"
    - "Add another user as member"
    - "Verify member can access tenant data"
    - "Verify user cannot access other tenants"
    - "Test tenant switching"
    - "Verify RLS blocks cross-tenant access"
